---
layout: post
title: 전송 계층(L4)
categories: Network
tags: [Network, CS]
---
- **PORT주소를 기반으로 목적지 컴퓨터의 해당 프로세스로 데이터 전송**
- 데이터가 정상적으로 전송되는지 제어하는 역할

### 로드밸런서(LB)
- 서버의 부하를 분산하기 위해 트래픽을 분배하는 기능을 한다  
(1) L4 로드 밸런싱 : TCP, UDP 정보(포트번호)를 기반으로 로드 밸런싱을 수행  
(2) L7 로드 밸런싱(=ADC) : HTTP와 같은 애플리케이션 프로토콜 정보를 기반으로 로드밸런싱을 수행
  - nginx

#### 부하 분산 알고리즘
1. 라운드 로빈 : `순차적으로 돌아가면서` 부하를 분산
2. 가중치 기반 라운드 로빈 : 라운드 로빈과 동일하지만 각 장비에 가중치를 두어 가중치가 더 높은 장비에 더많이 부하
3. 최소 접속 방식 : 활성화된 `세션수가 가장 적은 장비`로 부하
4. 가중치 기반 최소 접속 방식 : 최소 접속 방식과 동일하지만 각 장비에 가중치를 두어 가중치가 더 높은 장비에 더많이 부하
5. 해시 : 현재 서버의 부하는 고려하지 않고 `해시 알고리즘`을 이용해 부하를 분산

## TCP (Transmission Control Protocol)
- 가상회선 패킷 교환 방식 : 데이터 전송 전에 논리적 연결(가상회선)을 설정한다 
- 신뢰성 있는 연결형
  - 양방향 연결이 성립됐는지 확인하고 패킷을 전송한다 (1:1연결)
  - 패킷을 보낼 때는 패킷이 잘 전송됐는지 확인 한 후 다음 패킷을 전송한다
- 대량 전송(스트림 전송)
- 신뢰성이 높은 대신 속도가 느리다

- **순서 제어(오류시 순서 재조합), 오류 제어(데이터 손실 발견 및 교정), 흐름 제어, 혼합 제어**
- <span style="color:red">출발지 IP/PORT와 목적지 IP/PORT를 모두 고려하여 디멀티플렉싱이 된다</span>
  - 즉, 출발지가 다른 요청은 다른 요청으로 분류되어 각각 다른 소켓으로 들어온다(연결지향-사용자마다 다른 연결)

### TCP 헤더
![image](https://user-images.githubusercontent.com/48157259/164382637-56e86433-ead6-4a08-948a-369807bb3fec.png)
- 포트번호
- 시퀀스 번호(=세그먼트 번호) : 세그먼트 데이터부분의 맨 앞 시퀀스번호
- 응답 번호(=ACK번호) : 송신자로부터 다음순서로 받아야 할 시퀀스번호
- 윈도우 사이즈 : 수신자의 버퍼의 남아있는 공간
- 체크섬


### 오류 제어
1. 오류 탐지 : 요청의 오류여부를 체크섬으로 표시
2. 피드백 : 잘 받았는지 발신자에게 `ACK` or `NAK` 응답신호 전송 
3. 재전송 : `NAK`을 받으면 재전송

#### 윈도우 사이즈
- 송신자가 수신자에게 한번에 전송이 가능한 패킷의 양
- 슬라이딩 윈도우 : 네트워크 상황에 따라 윈도우 사이즈를 조절하는 것
   
#### 시퀀스 번호, 응답(ACK) 번호
- 분할된 패킷의 순서에 따라 번호(시퀀스 번호)를 부여하고 잘 전송이 됐는지 응답 번호(ACK번호)를 부여
- 송신자는 패킷에 번호를 부여하여 전송하면 수신자는 이 번호의 순서가 맞는지 확인한다
- 수신자는 순서가 맞다면 송신자에게 응답 번호로 `순서번호+1`을 해서 보내 다음번호를 달라고 응답한다
![image](https://user-images.githubusercontent.com/48157259/164148693-208a53ea-49c3-4a0a-abda-ca3b1e55f52c.png)
- 송신자는 매 전송마다 타이머를 돌리고 타임아웃이 될 때까지 응답이 오지 않으면 데이터가 유실됐다고 판단

#### 오류 제어 프로토콜
1. Stop-And-Wait
- 패킷을 전송하고 수신자로부터 응답신호를 받으면 다음 패킷을 전송
- 응답신호를 받을 때 까지 다음 패킷을 전송하지 않기 때문에 전송효율이 떨어진다

2. Go-Back-N
- 윈도우 사이즈만큼 한꺼번에 패킷을 전송
- 수신자는 한꺼번에 여러 패킷을 받지만 **순서에 맞지 않는 패킷을 먼저 받는다면 그 패킷의 재전송을 요청한다**
- 송신자는 수신자로부터 ACK를 받으면 슬라이딩 윈도우로 다음 패킷을 하나 더 전송한다
- 타임아웃이 발생하면 그 순간 윈도우의 패킷을 다시 전송한다
![image](https://user-images.githubusercontent.com/48157259/164183591-6b4e2343-f796-4caf-a829-f27eca2f7e03.png)

3. Seletive Repeat
- 윈도우 사이즈만큼 한꺼번에 패킷을 전송
- 수신자는 한꺼번에 여러 패킷을 받는데 **순서랑 상관없이 받는 패킷의 응답신호를 송신자에게 보낸다**
- 송신자는 수신자로부터 ACK를 받으면 슬라이딩 윈도우로 다음 패킷을 하나 더 전송한다
- 타임아웃이 발생하면 윈도우에서 응답신호를 받지 못한 패킷만 재전송한다
![image](https://user-images.githubusercontent.com/48157259/164186894-0baebbce-c42c-4c2c-b6ed-11cb1bb5b086.png)


### 흐름 제어(Flow Control)
- 송신자가 보내는 속도가 수신자가 받는 속도보다 빠르면 수신자쪽 버퍼에 남은 공간이 없어진다
- 송신자에게 수신자쪽 버퍼의 남아있는 공간을 알려줘 오버플로우가 나지 않을 정도의 패킷만 전송하도록 컨트롤 한다
  - TCP 헤더 `윈도우 사이즈`에 기록


### 혼잡 제어(Congestion Control)
- **네트워크 내**의 패킷 수가 넘치지 않게 방지
- 송신자는 공용 네트워크를 통해 수신자에게 패킷을 전달하는데 만일 이 네트워크가 혼잡해진다면 자신이 발송한 데이터도 처리할 수 없을 것이다
- 네트워크의 혼잡을 피하기 위해 송신자는 전송하는 패킷의 양(윈도우 사이즈)을 조절해야 한다
1. 느린 시작
2. 혼잡 회피

### 연결확립
#### 3-way-handshake
- 데이터 전송 전 **연결 설정**시 3번의 과정을 거침  
![image](https://user-images.githubusercontent.com/48157259/164149581-5e59309b-ecea-40ac-b12b-22c85372d4e2.png)
1. SYN(→) : 클라이언트가 서버로 SYN 신호를 전송하여 연결 요청  
2. SYN + ACK(←) : 서버가 클라이언트와 ACK 신호로 수락 응답, 서버에서 클라이언트로 SYN 신호를 전송하여 포트오픈 요청  
3. ACK(→) : 클라이언트가 서버로 ACK 신호로 수락 응답  

#### 4-way-handshake 
- 데이터 전송 후 **연결 해제**시 4번의 과정을 거침  
![image](https://user-images.githubusercontent.com/48157259/164149695-78dd6473-6a00-487d-8ceb-23591be66a95.png)
1. FIN(→) : 클라이언트가 서버로 FIN 신호를 전송하여 연결 종료요청  
2. ACK(←) : 서버가 클라이언트로 ACK 신호를 전송하여 종료요청 응답, 응답후 만약 전송할 데이터가 남아있으면 이어서 계속 전송  
3. FIN(←) : 모든 전송이 끝났으면 서버가 클라이언트로 FIN 신호를 전송하여 연결 종료 합의요청  
4. ACK(→) : 클라이언트가 서버로 ACK 신호를 전송하여 종료합의 응답  
- 클라이언트는 FIN을 받고 전송하는 ACK가 유실되는 상황에 대응하기 위해 FIN을 받고 특정시간동안 계속 열어놓다가 닫게 된다  


## UDP (User Datagram Protocol)
 - 데이터그램 패킷 교환 방식 : 데이터 전송 전에 논리적 연결을 설정하지 않으며 데이터그램을 전송한다
 - 비신뢰형, 비연결형으로 데이터그램 전송
 - 소량 전송, 실시간 전송
 - 신뢰성이 낮은 대신 속도가 빠르다
 - **실시간 스트리밍, 화상회의 등 유실 되더라도 계속해서 데이터를 전송할 때, 멀티캐스트처럼 단방향으로 다수의 단말과 통신해 응답을 받기 어려운 환경에서 사용**


 - 데이터 전달 및 순서가 보장되지 않지만, 단순하고 빠름
 - `IP(From 3계층) + PORT + 체크섬(오류여부)` 로 구성
   - 기능이 거의 없다 : 오류여부만 판단해서 목적지로 전송
 - <span style="color:red">오직 목적지 IP/PORT만 고려하여 디멀티플렉싱이 된다</span>

### UDP 헤더
- 포트번호와 체크섬만 존재해 아주 단순하다
![image](https://user-images.githubusercontent.com/48157259/164383008-79b8373c-3d81-4c84-ac36-782290712635.png)