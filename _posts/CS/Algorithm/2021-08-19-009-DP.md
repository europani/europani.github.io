---
layout: post
title: 동적 계획 알고리즘(Dynamic Programming)
categories: Algorithm
tags: [Algorithm, CS]
---

- **크고 복잡한 문제를 나누어 작고 간단한 여러 문제로 푸는 방식**
    - `분할 정복 알고리즘` : 간단한 문제가 될때 까지 문제를 나눈 다음 답을 도출하고 그 답들을 조합하여 원래 문제의 답을 도출
    - `최적 부분구조(Optimal Substructure)` : 작은 문제의 최적 솔루션이 큰 문제의 최적 솔루션에 포함
- 나누어진 문제를 풀다보면 재귀로 인한 중복된 하위 문제가 나타나 효율이 낮아지게 된다
- `DP테이블`을 이용하여 이전에 계산했던 값을 저장해 재사용하여 계산횟수를 줄일 수 있다
    - `메모이제이션(Memoization)` : 한번 계산한 결과를 메모리에 저장하여 다시 계산하지 않고 사용 (=캐싱)



#### 1. 피보나치 수열

- 재귀호출방식
```python
def fib(n):
    if n <= 1: 
        return n
     else:
        return fib(n-1) + fib(n-2)
```
- O(2<sup>n</sup>)

- Top-Down 방식(메모이제이션)
  - `재귀`를 사용하지만 dp테이블을 사용하여 이미 계산된 결과를 재사용한다

```python
def fib(n):
    if n<=1:
        return n

    # 계산된적 있을 때 : 캐싱
    if dp[n]:
        return dp[n]

    # 계산된적 없을 때
    dp[n] = fib(n-1) + fib(n-2)
    return dp[n]
```
- O(n)

- ★Bottom-Up 방식(DP)
  - `for문`을 사용하여 하위부터 차례로 풀어나간다

```python
n = int(input())
dp = [0] * (n+1)

def fib(n):
  dp[1]=1

  for i in range(2, n+1):
    dp[i] = dp[i-2] + dp[i-1]

  return dp[n]

print(fib(n))
```
- O(n)