---
layout: post
title: 주기억장치(Memory), 캐시메모리(Cache), 가상메모리
categories: OS
tags: [OS, CS]
---
![image](https://user-images.githubusercontent.com/48157259/143364687-2a78865d-22ff-4fb1-8d35-35569dad48cb.png)

## 주기억장치(Memory)
- 프로세스가 실행되기 위해서는 프로그램이 메모리에 올라와야 한다
- 프로그램을 보조기억장치에서 주기억장치로 적재시키면 그 프로그램은 실행되어 프로세스가 된다
- `OS가 사용하는 커널영역(낮은주소사용)`과 `USER가 사용하는 사용자영역(높은주소사용)`으로 구분 

### 주기억장치 관리 전략
#### 1. 반입(Fetch) 전략
: 보조기억장치에 보관중인 데이터를 **<u>언제</u>** 주기억장치에 적재할지 결정  
    (1) 요구 반입 : 실행중인 프로그램이 특정 데이터의 참조를 요구할 때 적재  
    (2) 예상 반입 : 실행중인 프로그램에 의해 참조된 특정 데이터를 미리 예상하여 적재

#### 2. 배치(Placement) 전략
: 새로 반입된 데이터를 주기억장치의 **<u>어디에</u>** 적재할지 결정  
    (1) 최초 적합(First Fit) : 배치 가능한 크기의 빈 영역중 **첫번째** 분할 영역에 배치  
    (2) 최적 적합(Best Fit) : 배치 가능한 크기의 빈 영역중 단편화가 **가장 적은** 분할 영역에 배치  
    (3) 최악 적합(Worst Fit) : 배치 가능한 크기의 빈 영역중 단편화가 **가장 많은** 분할 영역에 배치

    > 내부단편화 : 배치 후 남은 공간  
    > 외부단편화 : 배치를 못해 비어지게 된 공간

#### 3. 교체(Replacement) 전략
: 주기억장치의 모든 영역이 사용중일 때 어느 영역을 교체할지 결정  
ex) FIFO, OPT, LRU, LFU, NUR, SCR 등 [(링크)](https://europani.github.io/os/2021/04/02/005-page-replacement.html)



### 주기억장치 할당 기법
- 주기억장치에 프로그램을 어떻게 할당할 지 결정하는 기법

#### 1. 연속 할당 기법 : 프로그램 전체를 주기억장치에 적재

(1) 단일 분할 할당 기법
- 사용자영역에 오직 한명의 사용자만 사용가능
- 프로세스는 사용자영역에 올라가는데 **오직 1개의 프로그램만** 올라갈 수 있다
- 초기의 운영체제에서 많이 사용됨
  
- 오버레이 (Overlay) : 보조기억장치의 한 프로그램을 조각 분할 후 필요한 조각을 차례로 주기억장재 적재, 필요시 덮어씌움
- 스와핑 (Swapping) : 한 프로그램 전체를 주기억장치에 적재, 필요시 다른프로그램으로 교체
  - Swap out : 메모리에 적재되었던 프로그램이 교체되어 디스크로 쫒겨나는 것
  - Swap in : 프로그램이 메모리에 적재되는 것  

(2) 다중 분할 할당 기법 : 고정 분할(정적 할당), 가변 분할(동적 할당)
- 고정 분할 : 메모리를 고정된 크기로 분할
- 가변 분할 : 메모리를 필요한 크기만큼 분할


#### 2. 분산 할당 기법 : 프로그램을 조각으로 나누어 주기억장치에 분산 적재
- **가상 메모리**는 해당 기법을 사용힌다
- 여러 프로세스의 조각들이 주기억장치에 분산되어 섞여 배치되어도 맵핑테이블이 있어서 각 프로세스는 자신의 조각을 찾을 수 있다 

(1) 페이징 기법 : 프로그램과 주기억장치의 영역을 <span style="color:red">동일한 크기</span>로 나눠 주기억장치에 적재하는 기법 
- 내부 단편화 발생
- 동일한 크기로 나뉘어진 프로세스 조각을 `페이지`라고 한다
- 페이지 크기에 따라 동일한 크기로 나뉘어진 주기억장치의 조각을 `프레임`이라고 한다

(2) 세그먼테이션 기법 : 프로그램을 가변의 논리적 크기로 나눠 주기억장치에 적재하는 기법
- 가변의 크기로 나누는 기준은 프로그램의 Code, Data, Stack 영역 등의 논리적 단위이다
- 외부 단편화 발생
- 가변의 논리적 크기로 나뉘어진 프로세스 조각을 `세그먼트`라고 한다

## 가상메모리(Virtual Memory)
- 보조기억장치의 일부 공간을 주기억장치 처럼 사용하는 공간
- 프로그램 크기가 주기억장치보다 클 경우 실행이 불가능하게 되는데 이를 해결할 수 있다
  1. 주기억장치보다 실행하려는 프로그램 크기가 큰 경우
  2. 여러개의 프로그램을 동시에 실행할 때 여러개의 크기합이 주기억장치보다 큰 경우
- **프로세스를 여러 조각으로 나누어 필요한 부분만 주기억장치에 올리고 필요하지 않은 부분은 보조기억장치( 가상메모리)에 놔둔다**
- `요구 반입` 전략으로 주기억장치에 반입한다

### 논리주소 vs 물리주소
1. 논리주소 : 프로세스마다 독립적으로 가지는 주소(각 프로세스마다 0번지부터 시작)
  - CPU가 참조하는 주소
2. 물리주소 : 실제 메모리의 주소

### 블록 맵핑 테이블
- 각 블록(페이지/세그먼트)의 주소 변환을 위한 페이지의 위치 정보를 갖고 있는 테이블
- **각 블록이 저장된 가상메모리의 가상주소(논리주소) → 주기억장치의 실제주소(물리주소) 변환**
- <u>프로세스마다</u> 블록 맵핑 테이블을 생성한다
- 블록 맵핑 테이블은 OS에 의해 `주기억장치의 커널영역`에 위치한다

1. 페이지 맵핑 테이블(페이지 테이블)
   - 페이징 기법에서 주소 변환을 위해 사용하는 테이블
2. 세그먼트 맵핑 테이블(세그먼트 테이블)
   - 세그먼테이션 기법에서 주소 변환을 위해 사용하는 테이블



## 캐시메모리(Cache)
- 주기억장치에 저장된 내용의 일부를 임시로 저장해두는 기억장치
- CPU와 주기억장치 사이의 속도 차이로 인한 성능저하를 방지하기 위한 방법
- 속도가 주기억장치보다 빠르다

### 지역성
- 캐시메모리를 효율적으로 사용하기 위해서는 자주 사용하는 데이터를 캐시메모리에 적재해야 한다
- 이를 위해 시간기준과 공간기준으로 자주 사용하는 데이터를 예측한다

1. 시간지역성 : 최근에 접근한 데이터를 자주 사용하는 데이터로 예측
2. 공간지역성 : 최근에 접근한 데이터의 인접 데이터들을 자주 사용하는 데이터로 예측