---
layout: post
title: JPA
categories: Spring
tags: [Spring, JPA]
---
JPA는 자바 ORM 대한 표준 명세인 인터페이스이다. 그리고 JPA를 구현한 ORM 프레임워크에는 여러가지가 있다.  
JPA 구현체중에 `hibernate`가 가장 일반적이다.

### Entity
- 객체와 테이블 매핑

#### 어노테이션
- @Entity : JPA가 관리하는 클래스  
- @Table : 엔터티와 매핑할 테이블 지정  
<br>

- @Id : 속성 중 기본키  
- @Column : 일반속성  
  - @Column을 사용하지 않으면 변수명과 같은 컬럼명을 사용함
- @Enumerated : 자바의 enum 타입을 맵핑 
  - EnumType.ORDINAL: enum 순서로 저장 (0, 1)
  - EnumType.STRING **(권장)**: enum 이름으로 저장 (ADMIN, USER)
- @Temporal : 날짜 타입을 맵핑  
<br>

- @JoinColumn : 외래키 맵핑
- @ManyToOne : 다대일관계
  - fetch : 즉시로딩(eager) or 지연로딩(lazy) 선택
- @OneToMany : 일대다관계
  - mappedBy : 양방향 맵핑일 경우 반대쪽 맵핑의 필드 이름을 값으로 사용 (mappedBy="team")
- @OneToOne : 일대일관계
- @ManyToMany : 다대다관계 

```java
@Getter
@ToString(exclude = "team")                 // 중요! 지연로딩 사용시 제외
@NoArgsConstructor
@AllArgsConstructor
@Builder
@Entity
@Table(name = "member")
public class MemberEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;
    
    @Column(nullable = false)
    private String name;
    
    private String address;

    @Column(name = "zip_code", length = 10)
    private String zipCode;

    @CreationTimestamp 
    private Timestamp createDate;       // insert 시 시간 자동 저장 
    
    @UpdateTimestamp 
    private Timestamp updateDate;       // update 시 시간 자동 저장

    @Enumerated(EnumType.STRING)
    private RoleType roleType;

    @ManyToOne(fetch = FetchType.LAZY)      // 중요! 쿼리효율을 위해 항상 지연로딩 사용
    @JoinColumn(name = "TEAM_ID")
    private TeamEntity team;

    public void setTeam(Team team) {
        this.team = team;
    }

}

@Entity
public class TeamEntity {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private int id;
    
    @Column(nullable = false)
    private String name;
}

enum RoleType {
    ADMIN, USER
}
```

#### 기본키 매핑
1. 직접 할당 - @Id 사용

2. 자동 생성 - @Id, @GeneratedValue 함께 사용  
 ① IDENTITY : 기본 키 생성을 데이터베이스에 위임  
 ② SEQUENCE : 시퀀스 사용 (`@SequenceGenerator` 사용)  
 ③ TABLE : 시퀀스 생성용 테이블 이용 (`@TableGenerator` 사용)  
 ④ AUTO : 데이터베이스 방언에 따라 자동으로 선택 (Oracle:SEQUENCE / MySQL:IDENTITY)


### 기본 사용법  

|기능|메서드|설명|
|:---:|:---:|:---:|
|목록조회|createQuery(JPQL, Entity.class).getResultList()|엔티티 전체 목록 출력|
|상세조회|find(Entity.class, id)|엔티티 1개 출력|
|생성(Create)|persist(entity)|해당 엔티티 저장|
|수정(Update)|entity.setColumn(value)|해당 엔티티 수정|
|삭제(delete)|remove(entity)|해당 엔티티 삭제|

```java
@Repository
public static void MemberRepository() {

    @PersistenceContext
    EntityManager em;

    // 1. 생성
    public void save(MemberEntity member) {
        em.persist(member);
    }
    

    // 2. 1개 조회
    public MemberEntity findOne(Long id) {
        return em.find(MemberEntity.class, id);
    }

    // 3. 목록 조회
    public List<MemberEntity> findAll() {
        return em.createQuery("SELECT m from MemberEntity m", MemberEntity.class).getResultList();

    // 4. 수정
    public void update(MemberEntity member) {
        MemberEntity findMember = em.find(MemberEntity.class, member,getId());
        findMember.setName("name2");
    }

    // 5. 삭제
    em.remove(member);
    
}

```

### 영속성 컨텍스트(Persistence Context)
- 엔티티를 영구 저장하는 환경
- 엔티티 매니저가 영속성 컨텍스트에 엔티티를 보관하고 관리한다.
  - 엔티티 매니저(EntityManager) : 엔티티를 저장, 수정, 삭제, 조회 등 모든 일을 처리하는 관리자
<br>

1\. 1차 캐시
  - 영속성 컨텍스트 내부에 캐시가 있는데 이를 `1차 캐시` 라고 한다. 1차 캐시는 Map의 형태로 key:@Id, value:Entity 이다.
  - 엔티티 조회를 하면 우선 1차 캐시에서 ID값으로 엔티티를 찾는 데 없을 시 DB에 접근하여 조회 후 엔티티를 생성하여 1차 캐시에 저장 후 영속된 엔티티를 반환한다. 

```java
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");

em.persist(member);
```

2\. 동일성 보장
  - 같은 ID값으로 여러 번을 호출해도 같은 엔티티를 반환한다.

```java
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");

System.out.prineln(a == b);     // true
```

3\. 트랜잭션을 지원하는 쓰기 지연
  - 엔티티 매니저는 트랜잭션이 커밋되지 전까지 `내부 쿼리 저장소`에 SQL을 모아뒀다가 커밋시 한번에 DB로 보낸다(Flush).

4\. 변경 감지(Dirty Checking)
  - 수정하여 커밋하면 수정 후의 스냅샷과 엔티티가 영속성 컨텍스트에 처음 저장될 때의 스냅샷을 비교하여 변경된 엔티티를 찾는다. 
  - **영속성 컨텍스트에 존재하는 영속된 엔티티**만 적용된다.

5\. 지연 로딩
  - 엔티티 조회 시점이 아닌 엔티티 내 연관관계를 참조하는 시점에 필요한 데이터를 조회하는 것

```java
public void printUserAndTeam(String memberId) {
    Member member = em.find(Member.class, memberId);
    Team team = member.getTeam();
    team.getName();       // 실제 연관관계를 갖은 team 엔티티를 참조하는 시점 
}

public void printUser(String memberId) {
    Member member = em.find(Member.class, memberId);
}
```
→ `printUserAndTeam()` : Member와 연관관계를 갖는 `Team 엔티티`를 참조한다. 이 때, 지연로딩을 사용한다면 참조하는 시점에 조회한다.   
→ `printUser()` : `Member 엔티티`만 사용한다. 즉, Team 엔티티를 조회하는 것은 효율적이지 않다. 이 때, 조회하지 않은 Team 엔티티는 프록시로 대체한다.

◼︎ 프록시 : 실제 클래스를 상속 받아 겉모양이 같은 가짜 클래스
- 지연 로딩시 연관관계를 갖지만 조회되지 않은 엔티티는 프록시를 넣어둔다.

```java
public void printUserAndTeam(String memberId) {
    Member member = em.find(Member.class, memberId);
    Team team = member.getTeam();           // JPA는 Team의 프록시 객체를 넣어둠
    System.out.println(team.getClass());   // class hello.jpa.Team$HibernateProxy$z4JtUeLD
    team.getName();             // 연관관계를 참조하는 시점으로 DB조회가 실제로 일어남
}
```

#### 엔티티 생애주기
![](https://media.vlpt.us/images/neptunes032/post/ecd3b113-862f-4158-a208-e1eeec92d61d/image.png)

1\. 비영속(New) : 영속성 컨텍스트와 전혀 관계가 없는 상태
  - 엔티티 객체를 생성했지만 영속성 컨텍스트에 저장되지 않은 상태

```java
Member member = new Member();
```

<span style="color:red">2\. 영속(Managed) : 영속성 컨텍스트에 저장된 상태</span>
   - 엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장된 상태이며 <span style="color:red">영속성 컨텍스트에 의해 관리됨</span>

```java
em.persist(member);
```

3\. 준영속(Detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
  - 영속성 컨텍스트가 더 이상 엔티티를 관리하지 않는 상태
  - 다만, 이미 한번 영속이 되었던 적이 있기에 ID값을 갖고 있다.

```java
// 1. 특정 엔티티만 준영속상태로 전환
em.detach(member);
// 2. 영속성 컨텍스트 초기화
em.clear();
// 3. 영속성 컨텍스트 종료
em.close();
```

4\. 삭제(Removed) : 삭제된 상태
  - 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다.

```java
em.remove(member);
```

#### 플러시(flush)
- 영속성 컨텍스트의 변경 내용을 DB에 반영 하는 것

    1\. em.flush() 직접 호출 (거의 사용하지 않음)  
    2\. 트랜잭션 커밋시 자동 호출  
    3\. JPQL 실행시 자동 호출  