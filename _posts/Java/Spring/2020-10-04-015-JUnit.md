---
layout: post
title: '[JUnit] Junit 테스트 프레임워크'
categories: Spring
tags: [Spring, Junit]
---
Junit5 : Junit Platform + Junit Jupiter + Junit Vintage 모듈로 구성
1. Junit Platform : 테스트 프레임워크의 기본 API 제공
2. Junit Jupiter : Junit5의 새롭게 확장된 모델 제공
3. Junit Vintage : 하위 호환성을 위하여 Junit4, Junit3를 실행할 수 있는 모듈 제공

`spring-boot-starter-test`에 포함되어 있다.


### 어노테이션
#### 테스트
1. `@Test` : 단위테스트 메서드 명시
```java
@Test
void test() {
    ...
}
```

2. `@ParameterizedTest` : 매개변수가 있는 테스트 메서드 명시
```java
@ParameterizedTest
@ValueSource(string = {"europani"})
void test(String name) {
    ...
}
```

3. `@RepeatedTest` : 반복되는 테스트 메서드 명시
```java
@RepeatedTest(3)
void test() {
    ...
}
```

4. `@Disabled` : 테스트 비활성화  ~~[4버전 : @Ignore]~~

#### 라이프사이클
  - `@BeforeAll` -> `@BeforeEach` -> `@Test` -> `@AfterEach` -> `@AfterAll` 사이클 순서

1. `@BeforeAll` : 모든 테스트 전에 실행될 메서드 명시(테스트 클래스 수행시 1번만 실행)  ~~[4버전 : @BeforeClass]~~
   
2. `@AfterAll` : 모든 테스트 후에 실행될 메서드 명시(테스트 클래스 종료시 1번만 실행)  ~~[4버전 : @AfterClassx]~~

3. `@BeforeEach` : 각 단위테스트 전 마다 실행되는 메서드  ~~[4버전 : @Before]~~

4. `@AfterEach` : 각 단위테스트 후 마다 실행되는 메서드  ~~[4버전 : @After]~~
   
#### 기타
1. `@DisplayName` : 테스트 이름 지정 
   
2. `@Tag` : 테스트 필터링을 위한 태그 선언
   
3. `@Timeout` : 실행시간 제한 (실행시간을 초과하면 테스트 실패처리)
   
4. `@Order` : 테스트 순서 지정

```java
@Test
@Order(1)
void test_value() {
    ...
}

@Test
@Order(2)
void test_empty() {
    ...
}
```

#### assert 메서드 (org.junit.jupiter.api.Assertions.*)

|assert 메서드|설명|
|:---:|:---:|
|assertArrayEquals(a, b)|배열 a와 b가 일치하는지 확인|
|assertEquals(a, b)|객체 a와 b가 같은 값인지 확인|
|assertSame(a, b)|객체 a와 b가 같은 객체인지 확인|
|assertTrue(a)|조건 a가 참인지 확인|
|assertNotNull(a)|객체 a가 not Null인지 확인|
|assertThrows(exception.class, 코드)|해당 코드 실행시 예상한 exception가 발생하는지 확인|
|fail()|테스트 실패처리|


#### assertThat 관련 메서드 (org.assertj.core.api.Assertions.assertThat)
- junit5 에서는 `org.junit.Assert.assertThat` 이 존재하지 않기 때문에 다른 라이브러리를 사용해야 한다
- `AssertJ`, `Hamcrest` 등에 `assertThat`이 있지만 `AssertJ`를 추천한다 (Matcher를 외울 필요 없기 때문이다)  
    `org.assertj.core.api.Assertions.assertThat`


- assertThat 메서드  
    `assertThat(a).~~~` : 객체 a가 뒤에 설정한 특정조건 만족하는지 확인(커스터마이징)

◼︎ 조건 종류  
(1) 문자열
- isEqualTo(value) : value와 같은 값인지 확인
- isEmpty() : 비어있는지 확인
- isNull() : Null 인지 확인
- isNotNull() : Null이 아닌지 확인
- startsWith(value) : value로 시작하는지 확인
- endsWith(value) : value로 끝나는지 확인
- contains(value) : value가 포함되는지 확인

(2) 숫자
- isPositive() : 양수인지 확인
- isBetween(start, end) : start <= x <= end 인지 확인
- isGreaterThan(number) : number보다 큰 지 확인
- isLessThan(number) : number보다 작은 지 확인
- isZero() : 0 인지 확인

(3) 불리언
- isTrue() : true 인지 확인
- isFalse() : false 인지 확인

(4) Collection
- AllMatch(Predicate) : 람다식이 모두 맞는지 확인 
- anyMatch(Predicate) : 람다식이 맞는게 있는지 확인
- noneMatch(Predicate) : 람다식이 맞지 않는지 확인 

```java
// 리스트에 운영타입이 있는지 확인
assertThat(typeList).anyMatch(type -> type.getName().contains("운영"));     
```

- filterdOn(람다식 or 조건) : collection 객체에 필터 적용
  
```java
assertThat(userList).filterdOn(user -> user.getName()).isEqualTo("europani");
```

(5) 테스트 실패 메시지
- `as(description, args..)`를 통해 테스트 실패시 출력될 메시지를 정할 수 있다
- as는 반드시 검증문 앞에서 작성해야 한다

```java
@Test
void test() throws Exception {
    String str = "name";
    assertThat(str).as("값을 확인해주세요. 현재값 : %s", str).isEqualTo("name2");
}
```


[AssertJ공식문헌](https://assertj.github.io/doc/#assertj-core-assertions-guide)

#### Spring-Test 어노테이션

1. `@ExtendWith(SpringRunner.class)` : JUnit 테스트를 스프링 프레임워크와 통합 (테스트가 스프링 컨테이너에서 실행된다)  ~~[4버전 : @Runwith]~~

2. `@ContextConfiguration` : 스프링 설정파일 지정

3. `@SpringBootTest` : Spring Boot를 사용하는 경우 (테스트에 필요한 거의 모든 의존성을 제공)


### 테스트 케이스 작성
#### 테스트 작성법  
(1) given : 주어진 것  
(2) when : 실행했을때  
(3) then : 결과


```java
// 도메인
@Getter
@Setter
@NoArgsConstructor
public class Member {
      private Long id;
      private String name;
}

// 서비스
public class MemberService {
      private final MemberRepository memberRepository;

      public MemberService(MemberRepository memberRepository) {
          this.memberRepository = memberRepository;
      }
      ... 
}

// 리포지토리 인터페이스
public interface MemberRepository {
      Member save(Member member);
      Optional<Member> findById(Long id);
}

// 리포지토리 구현체
public class MemoryMemberRepository implements MemberRepository {
      private static Map<Long, Member> store = new HashMap<>();
      private static long sequence = 0L;

      @Override
      public Member save(Member member) {
          member.setId(++sequence);
          store.put(member.getId(), member);
          return member;
      }

      @Override
      public Optional<Member> findById(Long id) {
          return Optional.ofNullable(store.get(id));
      }

      public void clearStore() {
          store.clear();
        }
}
```


```java
@Transactional
class MemoryMemberRepositoryTest {
    MemoryMemberRepository repository = new MemoryMemberRepository();

    @AfterEach
    public void afterEach() {       // 여러번 테스트를 위해 매 테스트가 끝나면 cleanup
        repository.clearStore();
    }

    @Test
    public void save() {
        // 1. given
        Member member = new Member();
        member.setName("spring");

        // 2. when
        repository.save(member);

        // 3. then
        Member result = repository.findById(member.getId()).get();
        assertThat(result).isEqualTo(member);
    }
```

### 예외처리 테스트(assertThrows)

- `assertThrows(Class<T> expectedType, Executable executable)` : 두번째 인자의 코드를 실행할 때 첫번째 인자의 익셉션이 발생하는지 테스트

```java
@SpringBootTest
class ExceptionTest {

    @Autowired
    MemberService memberService;

    @Test
    @DisplayName("중복회원 가입 실패")
    public join() {
        // 1. Given
        Member member1 = new Member();
        member1.setName("spring");
        
        Member member2 = new Member();
        member2.setName("spring");

        // 2. When
        memberService.join(member1);
        // memberService.join()을 실행했을 때 IllegalStateException이 발생하는지
        IllegalStateException exception = assertThrows(IllegalStateException.class,
            () -> memberService.join(member2));

        // 3. Then
        assertEquals("이미 존재하는 회원입니다.", exception.getMessage());
    }

}

```

### MVC 테스트
- `@WebMvcTest`, `MockMvc` 클래스, `@MockBean`를 사용하여 MVC를 테스트 할 수 있다
- 웹에서 테스트 하기 힘든 **Controller**를 테스트 하기 적합하다
- `@WebMvcTest`는 `@Controller`, `@ControllerAdvice`를 읽는다
  - `@Service`, `@Repository`, `@Component`는 읽지 않는다
  - excludeFilters 속성을 사용하여 특정 필터를 테스트에서 제외시킬수 있다

```java
@Controller
public class BookController {

    @Autowired
    pirivate BookService bookService;

    @GetMapping("/books")
    public String getBookList(Model model) {
        List<Book> books = bookService.getBooks();
        model.addAttribute("books", books);

        return "book";
    }
}

@WebMvcTest(controllers = BookController.class)
public class BookControllerTest {

    @Autowired
    private MockMvc mvc;

    @MockBean
    private BookService bookService;

    @Test
    public void bookMvcTest() throw Exception {
        Book book = new Book("자바의 정석");

        mvc.perform(get("/books"))
                .andExpect(status().isOk())     // Http Code: 200 테스트
                .andExpcet(view().name("book")  // 반환 뷰 "book" 테스트
                .andExpcet(model().attributeExists("books")  // model Attribute 프로퍼티 "books" 존재하는지 테스트
                .andExpcet(model().attribute("books", contains(book))  // "Books" 프로퍼티에 book 객체가 존재하는지 테스트


    }
}
```