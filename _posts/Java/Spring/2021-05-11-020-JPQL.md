---
layout: post
title: '[JPA] JPQL'
categories: Spring
tags: [Spring, JPA]
---

- JPQL : Java Persistance Query Language  
- JPA에서 복잡한 SELECT문을 수행할 때 모든 데이터를 엔티티 객체로 변환하여 검색하는 것은 불가능하다.
- JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어를 제공한다.
- **엔티티 객체**를 대상으로 한 쿼리
- SELECT절, WHERE, GROUP BY, HAVING, JOIN, ORDER BY, 집합함수 등을 지원

\* 주의사항
- FROM뒤에 엔티티 입력
- JPQL 키워드는 대소문자 구분 X         ex) SELECT = select
- 엔티티와 속성은 대소문자 구분
- 엔티티에 **별명 필수**


### 기본 문법
- SELECT문

```java
String inputName = "europani"

TypeQuery<Member> query = em.createQuery("SELECT m FROM Member m WHERE m.name=:username", Member.class);

query.setParameter("username", inputName);
List<Member> resultList = query.getResultList();

# 체이닝
List<Member> resultList = em.createQuery("SELECT m FROM Member m WHERE m.name=:username", Member.class)
               .setParameter("username", inputName)
               .getResultList();
```



<hr>

### Spring-data-jpa 
- `@Query`를 사용하여 JPQL을 입력할 수 있다.

```java
@Repository
public interface MemberRepository extends JpaRepository<Member, Integer> {

     @Query("SELECT m FROM Member m")
     List<Member> selectAll();
}

```

#### LEFT JOIN
- 스프링부트 2 버전 부터는 엔티티 클래스 내에 연관관계가 없어도 Left Join이 가능하다

```java
@Entity
public class Member {
    
    @Id
    private String email;
    private String name;
}

@Entity
public class Board {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long bno;
    private String title;
    private String content;

    @ManyToOne(fetch=FetchType.LAZY)
    private Member member;
}

@Entity
public class Reply {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long rno;
    private String text;
    private String replyer;

    @ManyToOne(fetch=FetchType.LAZY)
    private Board board;
}
```
→ Board에서 Member로 접근 가능(연관관계 O) / Member에서 Board로 접근 불가(연관관계 X)  
→ Reply에서 Board로 접근 가능(연관관계 O) / Board에서 Reply로 접근 불가(연관관계 X)

1\. 연관관계가 있는 경우

```java
// ex) Board -> Member 접근
@Repository
public interface BoardRepository extends JpaRepository<Board, Long> {

     @Query("SELECT b, m FROM Board b LEFT JOIN b.member m WHERE b.bno=:bno")
     Object getBoardWithWriter(@Param("bno") Long bno);
}
```

2\. 연관관계가 없는 경우
   - LEFT JOIN 할 엔티티를 직접 입력하고 `ON` 키워드를 사용하여 연결

```java
// ex) Board -> Reply 접근
@Repository
public interface BoardRepository extends JpaRepository<Board, Long> {

     @Query("SELECT b, r FROM Board b LEFT JOIN Reply r ON r.board=b WHERE b.bno=:bno")
     Object getBoardWithReply(@Param("bno") Long bno);
}
```

### Fetch Join(페치 조인)
- 기존 SQL의 조인 종류가 아니고 JPQL의 성능 튜닝을 위해 JPA에서 제공하는 조인이다
- **연관된 엔티티 or 컬렉션을 SQL 한번에 함께 조회하는 기능**

- Member:Team = N:1(다대일) 양방향 관계를 갖는 두 엔티티

```java
@Entity
public class Member {
    @Id
    private String id;
    private String username;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name="team_id")
    private Team team;
}

@Entity
public class Team {
    @Id
    private String id;
    private String name;

    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<Member>();
}
```

- 페치조인 사용 : `JOIN` 뒤에 `FETCH <조인컬럼>` 입력한다

```java
String jpql = "SELECT m FROM Member m JOIN FETCH m.team"

List<Member> members=em.createQuery(jpql, Member.class)
            .getResultList();
```

```SQL
SELECT m.*, t.* FROM member m INNER JOIN team t ON m.team_id=t.id
```
- 즉시로딩으로 조회한 것과 같은 결과가 나온다
- 지연로딩을 사용했지만 페치조인을 사용했기 때문에 연관된 team 엔티티는 프록시가 아닌 실제 엔티티가 되어 지연로딩이 일어나지 않는다

#### @EntityGraph
- `JPQL`을 작성할 수 없을 때나 `JpaRepository`가 제공하는 기능에 페치조인을 적용하고 싶을 때 사용할 수 있다
- 또 여러 개를 fetch join 시킬때 사용할 수 있다

```java
@Repository
public interface MemberRepository extends JpaRepository<Member, Integer> {

     @EntityGraph(attributePaths = {"team"})
     Member findByUsername(String username);
}
```


#### 컬렉션 페치조인 (1:N 관계)
- 이번엔 반대방향으로 페치조인을 하겠다

```SQL
jpql = "SELECT t FROM team t JOIN FETCH t.member"

SELECT t.*, m.* FROM team t INNER JOIN member m ON t.id=m.team_id
```
- 반대방향도 똑같은 결과가 나타난다


#### 일반조인 vs 페치조인

```SQL
jpql = "SELECT t FROM team t JOIN t.member m"

SELECT t.* FROM team t INNER JOIN member m ON t.id=m.team_id
```

```SQL
jpql = "SELECT t FROM team t JOIN FETCH t.member"

SELECT t.*, m.* FROM team t INNER JOIN member m ON t.id=m.team_id
```
- 일반조인의 SELECT문을 보면 팀만 조회되고 조인했던 회원은 전혀 조회되지 않았다

**<span style="color:red;">글로벌 로딩전략을 즉시 로딩으로 설정하면 애플리케이션의 성능에 영향을 미친다. 글로벌 로딩전략을 지연 로딩으로 설정하고 최적화가 필요하면 페치조인을 적용하는 것이 가장 베스트이다</span>**

#### N+1 문제
연관관계를 갖는 엔티티로 JPQL을 사용할 때 SQL 결과인 N번에 실행 SQL 1번이 더해진 N+1번의 SQL이 실행되는 문제

1\. EAGER 로딩 전략 사용시

```java
@Entity
public class Member {
    @Id
    private String id;
    private String username;

    @OneToMany(mappedBy="member", fetch=FetchType.EAGER)
    private List<Order> orders = new ArrayList<Order>)();
}

@Entity
class Order {
    @Id
    private Long id;

    @ManyToOne
    private Member member;
}
```

```java
List<Orders> orders=em.createQuery("SELECT m FROM Member m", Member.class)
            .getResultList();
```

```SQL
SELECT * FROM member                 // JPQL로 실행된 SQL
SELECT * FROM order WHERE member_id=?     // 지연로딩으로 실행된 SQL들
SELECT * FROM order WHERE member_id=?
SELECT * FROM order WHERE member_id=?
SELECT * FROM order WHERE member_id=?
...
```
- JPQL로 SQL을 생성하여 실행한다. 그 결과를 엔티티에 담는다
- 즉시로딩 전략이기에 order에 연관된 member를 영속성 컨텍스트에서 찾는데 없을 시 SQL을 실행한다
- 그 결과 결과수 만큼의 SQL이 추가로 실행된다


2\. LAZY 로딩 전략으로 데이터를 가져온 이후 가져온 데이터에서 하위 엔티티를 다시 조회하는 경우

```java
@Entity
public class Member {
    ...
    @OneToMany(mappedBy="member", fetch=FetchType.LAZY)
    private List<Order> orders = new ArrayList<Order>)();
    ...
}
```

```java
List<Orders> orders=em.createQuery("SELECT m FROM Member m", Member.class)
            .getResultList();
```

```SQL
SELECT * FROM member
```
- 이 경우에는 지연로딩으로 JPQL에서 회원만 조회해서 N+1 문제가 발생하지 않는다
- 다만, 이후 비즈니스 로직에서 조회되지 않는 주문 데이터를 사용할 때 이를 조회하기 위해 N+1 문제가 발생한다

```SQL
SELECT * FROM order WHERE member_id=?
SELECT * FROM order WHERE member_id=?
SELECT * FROM order WHERE member_id=?
SELECT * FROM order WHERE member_id=?
...
```

★ 해결방안 : FETCH 조인사용
- 페치 조인을 사용하면 SQL 조인을 사용하여 연관된 엔티티를 함께 가져오기 때문에 N+1 문제가 발생하지 않는다

```SQL
jpql = "SELECT m FROM Member m JOIN FETCH m.order"

SELECT m.*, o.* FROM member m INNER JOIN order o ON m.id=o.member_id
```