---
layout: post
title: 디자인 패턴 소개
categories: [Design Pattern]
tags: [Design Pattern]
---

### 디자인 패턴
- 과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 이후에 재사용하기 좋은 형태로 특정 규약을 만들어서 정리한 것이다
- 효율적인 코드를 만들기 위한 방법론

### 디자인 패턴의 구조
1. 컨텍스트(Context) : 문제가 발생하여 패턴을 적용시킬 수 있는 상황
2. 문제(Problem) : 패턴이 적용되어 해결 될 필요가 있는 이슈
3. 해결(Solution) : 문제를 해결하도록 설계를 구성하는 요소들과 그 요소들 사이의 관계, 책임, 협력 관계

### 디자인 패턴의 종류
#### 1. 생성 패턴
- 객체 생성과 관련된 패턴
- 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공한다

(1) 추상팩토리 : 구제적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공  
(2) **빌더** : 복합 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 패턴  
(3) 팩토리메소드 : 객체생성을 하위클래스로 분리하여 캡슐화  
(4) 프로토타입 : 객체의 프로토타입을 만들고 인스턴스를 생성할 때 프로토타입을 복제  
(5) **싱글톤** : 클래스의 인스턴스를 하나만 생성하여 사용



#### 2. 구조 패턴
- 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴

(1) **어댑터**: 다른 클래스의 인터페이스를 이용할 수 있게 변환  
(2) 브리지 : 기능(클래스)과 구현(클래스)을 독립적으로 만든다음 연결  
(3) 컴포지트 : 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴  
(4) **데코레이터** : 기존 코드를 수정하지 않고 새로운 기능으로 확장  
(5) 퍼싸드 : 상위에 인터페이스 구성 (각 각의 클래스를 상위에서 통합)  
(6) 플라이웨이트 : 용량이 큰 클래스를 메모리 절약을 위해 공유해서 사용 (싱글톤과 비슷)   
(7) **프록시** : 접근이 어렵기에 간접적으로 접속을 도와줌 -> 인터페이스 역할


#### 3. 행위 패턴
- 객체나 클래스 사이의 알고리즘이나 책임 분배하는 패턴
- 한 객체가 단독으로 수행할 수 없는 작업을 여러 객체에 어떻게 나눌 것이며 결합도를 최소화 시키는 데 중점을 둔다

(1) 책임연쇄 : 한 객체에서 처리 못하면 다음 객체로 넘어감  
(2) 커맨드 : 실행될 기능(커맨드)을 캡슐화하여 재사용성이 높은 클래스를 설계  
(3) 인터프리터 : 문법 정의  
(4) 반복자 : 반복해서 접근할 수 있게 인터페이스  
(5) 중재자 : 객체들간의 상호작용을 캡슐화  
(6) 메멘토 : 특정 시점의 객체상태를 객체화후 돌림(ctrl+z)  
(7) 옵서버 : 변수를 관찰하고 있다가 변화가 생기면 특정 클래스에게 전달하여 그에 맞게 행동하게 만듦   
(8) 상태 : 객체 상태에 따라 다르게 처리  
(9) **전략** : 기능을 인터페이스로 캡슐화 하고 이를 implements 받아 하위에서 구현 (인터페이스)  
(10) **템플릿메소드** : 상위클래스에서 골격 정의, 하위 클래스에서 상속 받아 구체화 (클래스)  
(11) 방문자 : 처리 기능을 분리해서 별도의 클래스로 구성 -> 여기에 방문함