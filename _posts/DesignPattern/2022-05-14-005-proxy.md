---
layout: post
title: 구조 (2) - 프록시(Proxy) 패턴
categories: [Design Pattern]
tags: [Design Pattern]
---
- 특정 객체에 대한 접근을 제어하거나 기능을 추가할 수 있는 패턴
- 특정 객체를 접근하기 전에 프록시 객체를 먼저 접근해야 한다 (like 비서)
- **흐름제어만 할 뿐** 결과값을 조작하거나 변경시켜서는 안된다
- 초기화 지연, 접근 제어, 로깅, 캐싱 등 다양하게 응용해 사용할 수 있다

![image](https://user-images.githubusercontent.com/48157259/168471773-9ffcafc6-6d11-45f0-935e-996ce487ef68.png)

- 클라이언트(Client)가 어떤 요청을 하면(RealSubject의 `DoAction()`) 프록시가 대신 RealSubject의 `DoAction()`을 호출하고 반환 값은 클라이언트에게 반환한다

### 구현
- interface

```java
public interface Subject {
   String request();
}
```

- RealSubject

```java
public class RealSubject implements Subject {

    @Override
    public String request() {
        return "Hello World!";
    }
}
```

- Proxy
  - RealObject가 구현하고 있는 interface를 구현한다
  - 필드에 RealObject를 갖고 있음

```java
public class Proxy implements Subject {

    private final RealSubject realSubject = new RealSubject();

    @Override
    public String request() {
        System.out.println("Proxy work");
        return realSubject.request();
    }
}
```

- Client(Main 메서드)
  - 프록시 객체를 통해 실행한다

```java
public class Main {

    public static void main(String[] args) {
        Subject subject = new Proxy();
        System.out.println(subject.request());
    }
```


### 장점
1. 기존 코드를 변경하지 않고 새로운 기능을 추가할 수 있다 [OCP]
2. 생성비용이 큰 객체를 구동시 생성하지 않고 실제 사용시 생성시킬 수 있다(초기화 지연)
3. 접근을 제어할 수 있다

### 단점
1. 코드의 복잡도가 증가한다